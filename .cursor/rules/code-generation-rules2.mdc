# 추가 코드 생성 규칙

## 1. 공통 모듈 활용 규칙

### 1.1 기존 공통 모듈 우선 활용
- **@common/ 패키지**: 기존 공통 모듈을 우선적으로 활용
  - `com.kh.demo.domain.common.base.BaseSVC`, `BaseDAO`
  - `com.kh.demo.domain.common.svc.CodeSVC`, `FileUploadService`
  - `com.kh.demo.domain.common.util.ValidationUtils`, `MemberAuthUtil`
  - `com.kh.demo.domain.common.exception.BusinessValidationException`
- **새로운 공통 기능 추가 시**: 기존 패턴을 따라 `@common/` 패키지에 추가
- **중복 코드 금지**: 기존 공통 모듈이 있으면 새로 작성하지 말고 활용

### 1.2 공통 리소스 활용
- **common.css**: 모든 페이지에서 공통으로 사용되는 스타일
- **common.js**: 모든 페이지에서 공통으로 사용되는 JavaScript 함수들
- **layout.html**: 모든 페이지의 기본 레이아웃 템플릿
- **fragment/**: 재사용 가능한 UI 컴포넌트 (top, footer, menu, auth 등)

### 1.3 공통 모듈 활용 예시
```java
// ❌ 잘못된 예: 새로 작성
public class NewService {
    private void validateEmail(String email) {
        // 중복 코드 작성
    }
}

// ✅ 올바른 예: 기존 공통 모듈 활용
public class NewService {
    private final ValidationUtils validationUtils;
    
    public void someMethod(String email) {
        validationUtils.validateEmail(email); // 기존 공통 모듈 활용
    }
}
```

## 2. 컨트롤러 패턴 규칙

### 2.1 컨트롤러 분리 원칙
- **API 컨트롤러**: `@RestController`, JSON 응답, `/api/` 경로
  - 위치: `web/{도메인}/controller/api/`
  - 예: `ProductApiController`, `MemberApiController`
- **페이지 컨트롤러**: `@Controller`, Thymeleaf 뷰, 일반 경로
  - 위치: `web/{도메인}/controller/page/`
  - 예: `ProductController`, `MemberController`

### 2.2 컨트롤러 구조 예시
```java
// API 컨트롤러
@RestController
@RequestMapping("/api/products")
public class ProductApiController extends BaseApiController {
    @PostMapping
    public ResponseEntity<ApiResponse<ProductResponse>> create(@RequestBody @Valid ProductRequest request) {
        // JSON 응답
    }
}

// 페이지 컨트롤러
@Controller
@RequestMapping("/products")
public class ProductController extends BaseController {
    @GetMapping("/list")
    public String list(@ModelAttribute ProductSearchForm form, Model model) {
        // Thymeleaf 뷰 반환
    }
}
```

## 3. 유효성 검증 규칙

### 3.1 필드 레벨 유효성 검증
- **Form/DTO 클래스**: `@Valid`, `@NotNull`, `@Size` 등 어노테이션 사용
- **위치**: 요청 객체에 직접 적용
- **예시**:
```java
public class MemberJoinForm {
    @NotBlank(message = "이메일은 필수입니다")
    @Email(message = "올바른 이메일 형식이 아닙니다")
    private String email;
    
    @NotBlank(message = "비밀번호는 필수입니다")
    @Size(min = 8, message = "비밀번호는 8자 이상이어야 합니다")
    private String password;
}
```

### 3.2 비즈니스 로직 유효성 검증
- **컨트롤러 레벨**: 2개 이상의 필드 조합 검증
- **서비스 레벨**: 복잡한 비즈니스 규칙 검증
- **예시**:
```java
@PostMapping("/join")
public String join(@Valid @ModelAttribute MemberJoinForm form, 
                   BindingResult bindingResult, 
                   Model model) {
    // 필드 레벨 검증 (자동)
    if (bindingResult.hasErrors()) {
        return "member/joinForm";
    }
    
    // 비즈니스 로직 검증 (수동)
    if (!form.getPassword().equals(form.getPasswordConfirm())) {
        bindingResult.rejectValue("passwordConfirm", "error.passwordConfirm", "비밀번호가 일치하지 않습니다");
        return "member/joinForm";
    }
    
    // 서비스 호출
    memberService.join(form);
    return "redirect:/login";
}
```

## 4. 예외 처리 규칙

### 4.1 기존 예외 클래스 우선 활용
- **`BusinessException`**: 모든 비즈니스 예외의 기본 클래스로 사용
- **`BusinessValidationException`**: 유효성 검증 실패 시 사용
- **`ErrorCode`**: 에러 코드는 중앙에서 관리된 것만 사용

### 4.2 예외 처리 패턴
```java
// ❌ 잘못된 예: 새로운 예외 클래스 생성
public class CustomException extends RuntimeException {
    // 중복 코드
}

// ✅ 올바른 예: 기존 예외 클래스 활용
public class SomeService {
    public void someMethod() {
        if (invalidCondition) {
            throw ErrorCode.INVALID_INPUT.toException("구체적인 오류 메시지");
        }
    }
}
```

### 4.3 예외 처리 계층
- **서비스 레이어**: `BusinessException` 또는 `BusinessValidationException` 발생
- **컨트롤러 레이어**: `@ExceptionHandler`로 처리 (기존 글로벌 핸들러 활용)
- **글로벌 처리**: `GlobalExceptionHandler` (SSR), `GlobalRestControllerAdvice` (REST API)

### 4.4 에러 코드 사용 규칙
```java
// ❌ 잘못된 예: 하드코딩된 에러 메시지
throw new RuntimeException("사용자를 찾을 수 없습니다");

// ✅ 올바른 예: 중앙화된 에러 코드 사용
throw ErrorCode.MEMBER_NOT_FOUND.toException();
```

## 5. 기존 코드 활용 체크리스트

### 5.1 새 기능 개발 시 확인사항
- [ ] `@common/` 패키지에 유사한 기능이 있는지 확인
- [ ] `common.js`, `common.css`에 재사용 가능한 코드가 있는지 확인
- [ ] `fragment/`에 재사용 가능한 UI 컴포넌트가 있는지 확인
- [ ] 기존 컨트롤러 패턴(page/api)을 따르는지 확인
- [ ] 기존 명명 규칙을 따르는지 확인
- [ ] 기존 예외 처리 체계를 활용하는지 확인

### 5.2 공통 모듈 추가 시 규칙
- [ ] `@common/` 패키지의 기존 패턴을 따라 작성
- [ ] 적절한 인터페이스와 구현체 분리
- [ ] JavaDoc 주석 작성
- [ ] 단위 테스트 작성
- [ ] 기존 코드에서 활용 가능하도록 설계

## 6. 일관성 유지 규칙

### 6.1 패키지 구조 일관성
```
com.kh.demo.domain.{도메인명}/
├── dao/           # 데이터 접근 객체
├── entity/        # 엔티티 클래스
├── svc/           # 서비스 인터페이스
├── dto/           # 데이터 전송 객체
└── vo/            # 뷰 객체

com.kh.demo.web.{도메인명}/
├── controller/
│   ├── api/       # REST API 컨트롤러
│   └── page/      # 페이지 컨트롤러
└── dto/           # 웹 전용 DTO
```

### 6.2 명명 규칙 일관성
- **API 컨트롤러**: `~ApiController`
- **페이지 컨트롤러**: `~Controller`
- **요청 객체**: `~Request` (API), `~Form` (페이지)
- **응답 객체**: `~Response` (API), `~Dto` (페이지)
- **서비스**: `~Service`, `~ServiceImpl`
- **DAO**: `~DAO`, `~DAOImpl`

### 6.3 어노테이션 일관성
```java
// API 컨트롤러
@RestController
@RequestMapping("/api/{도메인}")
@RequiredArgsConstructor
public class {도메인}ApiController extends BaseApiController {
    @PostMapping
    public ResponseEntity<ApiResponse<{응답}>> method(@RequestBody @Valid {요청} request) {
        // JSON 응답
    }
}

// 페이지 컨트롤러
@Controller
@RequestMapping("/{도메인}")
@RequiredArgsConstructor
public class {도메인}Controller extends BaseController {
    @GetMapping("/{페이지}")
    public String method(@ModelAttribute {폼} form, Model model, HttpSession session) {
        // Thymeleaf 뷰 반환
    }
}
```

## 7. 공통 파일 및 예외처리 규칙

### 7.1 CSS/JS 공통 파일 사용
- **common.css**: 모든 페이지에서 공통으로 사용되는 스타일
- **common.js**: 모든 페이지에서 공통으로 사용되는 JavaScript 함수들
- **layout.html**: 모든 페이지의 기본 레이아웃 템플릿

### 7.2 예외처리 규칙
- **@ControllerAdvice**: 전역 예외처리 클래스 사용
- **@ExceptionHandler**: 각 컨트롤러별 예외처리 메서드 구현
- **BusinessException**: 비즈니스 로직 예외 처리
- **ValidationException**: 입력값 검증 예외 처리

### 7.3 코드 서비스 예외처리
- **@Transactional**: 데이터베이스 작업 시 트랜잭션 관리
- **try-catch**: 서비스 레이어에서 예외 발생 시 적절한 예외 변환
- **로깅**: 예외 발생 시 상세한 로그 기록

## 8. 컨트롤러 요청/응답 데이터 클래스 명명 규칙

### 8.1 REST API 컨트롤러
- **요청 클래스**: `~Request` 접미사 사용
  - 예: `MemberJoinRequest`, `ProductSearchRequest`
- **응답 클래스**: `~Response` 접미사 사용
  - 예: `MemberDetailResponse`, `ProductListResponse`

### 8.2 페이지 컨트롤러
- **양식(Form) 클래스**: `~Form` 접미사 사용
  - 예: `MemberJoinForm`, `ProductAddForm`
- **일반 DTO 클래스**: `~Dto` 접미사 사용
  - 예: `MemberSearchDto`, `ProductListDto`

### 8.3 클래스 구조 예시
```java
// REST API
@RestController
public class MemberApiController {
    @PostMapping("/api/members")
    public MemberJoinResponse join(@RequestBody @Valid MemberJoinRequest request) {
        // ...
    }
}

// 페이지 컨트롤러
@Controller
public class MemberController {
    @GetMapping("/members/join")
    public String joinForm(@ModelAttribute MemberJoinForm form) {
        // ...
    }
    
    @PostMapping("/members/search")
    public String search(@ModelAttribute MemberSearchDto searchDto) {
        // ...
    }
}
```

## 9. 엔티티 클래스 규칙

### 9.1 테이블 구조 일치
- **엔티티 클래스**: 데이터베이스 테이블 구조와 100% 일치
- **필드명**: 테이블 컬럼명과 동일하게 매핑
- **데이터 타입**: Oracle 데이터 타입에 맞는 Java 타입 사용

### 9.2 엔티티 클래스 구조
```java
public class Member {
    private Long memberId;        // MEMBER_ID 컬럼
    private String email;         // EMAIL 컬럼
    private String nickname;      // NICKNAME 컬럼
    private String gubun;         // GUBUN 컬럼
    private LocalDateTime createdDate;  // CREATED_DATE 컬럼
    private LocalDateTime updatedDate;  // UPDATED_DATE 컬럼
    
    // getter/setter 메서드
}
```

### 9.3 명명 규칙
- **클래스명**: 테이블명을 PascalCase로 변환
  - 예: `MEMBER` → `Member`, `PRODUCT_INFO` → `ProductInfo`
- **필드명**: 컬럼명을 camelCase로 변환
  - 예: `MEMBER_ID` → `memberId`, `CREATED_DATE` → `createdDate`
- **기본키**: `~Id` 형태로 명명
  - 예: `memberId`, `productId`, `orderId`

### 9.4 데이터 타입 매핑
- **VARCHAR2** → `String`
- **NUMBER** → `Long` (ID), `Integer` (일반 숫자)
- **DATE** → `LocalDateTime`
- **TIMESTAMP** → `LocalDateTime`
- **CLOB** → `String`
- **BLOB** → `byte[]`

## 10. 검색 및 트랜잭션 처리 규칙

### 10.1 검색 기능 - Elasticsearch 활용
- **검색 기능**: 모든 검색 관련 기능은 Elasticsearch 사용
- **검색 대상**: 상품, 게시판, 회원 등 검색이 필요한 모든 데이터
- **검색 서비스**: `~SearchService` 형태로 명명
- **검색 결과**: Elasticsearch에서 검색 후 Oracle에서 상세 정보 조회

### 10.2 트랜잭션 처리 - Oracle 활용
- **데이터 저장/수정/삭제**: 모든 CRUD 작업은 Oracle 사용
- **트랜잭션 관리**: `@Transactional` 어노테이션 필수 적용
- **데이터 동기화**: Oracle 데이터 변경 시 Elasticsearch 인덱스 자동 업데이트

### 10.3 아키텍처 패턴
```java
// 검색 서비스 예시
@Service
public class ProductSearchService {
    
    // Elasticsearch로 검색
    public List<ProductSearchResult> searchProducts(String keyword) {
        // Elasticsearch 검색 수행
        List<ProductSearchResult> searchResults = elasticsearchRepository.search(keyword);
        return searchResults;
    }
    
    // Oracle에서 상세 정보 조회
    public ProductDetail getProductDetail(Long productId) {
        return productRepository.findById(productId);
    }
}

// 트랜잭션 서비스 예시
@Service
@Transactional
public class ProductService {
    
    public void createProduct(ProductCreateRequest request) {
        // Oracle에 저장
        Product product = productRepository.save(request.toEntity());
        
        // Elasticsearch 인덱스 업데이트
        elasticsearchRepository.index(product);
    }
    
    public void updateProduct(Long productId, ProductUpdateRequest request) {
        // Oracle 업데이트
        Product product = productRepository.update(productId, request);
        
        // Elasticsearch 인덱스 업데이트
        elasticsearchRepository.update(product);
    }
}
```

### 10.4 데이터 동기화 규칙
- **실시간 동기화**: Oracle 데이터 변경 시 즉시 Elasticsearch 업데이트
- **배치 동기화**: 대량 데이터 처리 시 배치 작업으로 동기화
- **오류 처리**: 동기화 실패 시 재시도 로직 구현

## 11. 프로젝트 특화 규칙

### 11.1 도메인 구조 규칙
- **도메인 패키지**: `com.kh.demo.domain.{도메인명}`
- **도메인별 구조**: `dao/`, `entity/`, `svc/` 패키지 필수
- **도메인 목록**: member, product, cart, order, payment, board, review, wishlist, notification, report

### 11.2 웹 컨트롤러 구조 규칙
- **웹 패키지**: `com.kh.demo.web.{도메인명}`
- **컨트롤러 분리**: API용 `~ApiController`, 페이지용 `~Controller`
- **관리자 패키지**: `com.kh.demo.admin.controller.{api/page}`

### 11.3 세션 및 권한 관리 규칙
- **세션 클래스**: `LoginMember` 사용
- **권한 구분**: 일반(2), VIP(3), 관리자1(4), 관리자2(5)
- **인터셉터**: `LoginCheckInterceptor`로 권한별 접근 제어
- **세션 접근**: `${session?.loginMember?.property}` 형태로 사용

### 11.4 파일 업로드 규칙
- **업로드 경로**: `uploads/` 디렉토리
- **이미지 타입**: jpg, jpeg, png, gif, webp
- **문서 타입**: pdf, doc, docx, txt
- **최대 크기**: 이미지/문서 각각 10MB
- **정적 리소스**: `/uploads/**` 경로로 접근

### 11.5 코드 관리 규칙
- **코드 테이블**: 계층형 구조 지원 (code_id, pcode, code_level)
- **코드 경로**: `code_path` 필드로 전체 경로 저장
- **정렬 순서**: `sort_order` 필드로 정렬
- **사용 여부**: `use_yn` 필드로 활성화/비활성화 관리

### 11.6 게시판 계층 구조 규칙
- **계층형 게시판**: `bgroup`, `step` 필드로 계층 구조 구현
- **답글 구조**: `rgroup`, `rstep` 필드로 답글 계층 구현
- **카테고리**: `bcategory` 필드로 게시판 분류

### 11.7 리뷰 시스템 규칙
- **리뷰 상태**: 활성/비활성 상태 관리
- **리뷰 댓글**: 계층형 댓글 구조
- **리뷰 신고**: 신고 시스템 및 자동 처리 규칙
- **평점 시스템**: 1-5점 평점 관리

### 11.8 주문/결제 시스템 규칙
- **주문 상태**: 주문 진행 단계별 상태 관리
- **결제 상태**: 결제 진행 단계별 상태 관리
- **장바구니**: 임시 저장 → 주문 생성 → 결제 완료 흐름
- **위시리스트**: 상품 찜하기 기능

### 11.9 알림 시스템 규칙
- **알림 타입**: 시스템별 알림 타입 관리
- **읽음 상태**: `is_read` 필드로 읽음/안읽음 관리
- **대상 타입**: 알림 대상 타입별 관리
- **실시간 알림**: WebSocket 또는 SSE 활용

### 11.10 검색 로그 시스템 규칙
- **검색 기록**: 사용자별 검색 히스토리 저장
- **인기 검색어**: 검색어 빈도 집계
- **검색 타입**: 상품, 게시판, 회원 등 타입별 분류
- **개인화**: 사용자별 맞춤 검색 결과 제공

### 11.11 자동화 규칙 시스템
- **자동 처리**: 신고 건수에 따른 자동 제재
- **규칙 설정**: 관리자가 자동화 규칙 설정 가능
- **통계 관리**: 신고 통계 및 처리 현황 관리
- **이력 관리**: 모든 처리 이력 보관

### 11.12 설정 파일 규칙
- **application.yml**: 메인 설정 파일
- **messages.properties**: 국제화 메시지
- **spy.properties**: SQL 로깅 설정
- **환경변수**: API 키, 이메일 설정 등 민감 정보

### 11.13 로깅 규칙
- **로그 레벨**: DEBUG, INFO, WARN, ERROR 적절히 사용
- **SQL 로깅**: NamedParameterJdbcTemplate 로그
- **Elasticsearch 로그**: 검색 관련 로그
- **예외 로깅**: 상세한 스택 트레이스 기록

### 11.14 AI 통합 규칙
- **OpenAI 연동**: ChatClient를 통한 AI 기능
- **환경변수**: OPENAI_API_KEY 설정
- **AI 서비스**: 챗봇, 추천 시스템 등 활용
- **에러 처리**: AI 서비스 실패 시 graceful degradation
